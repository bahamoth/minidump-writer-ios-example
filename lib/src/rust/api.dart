// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`

enum CrashType {
  segfault,
  abort,
  busError,
  divideByZero,
  illegalInstruction,
  stackOverflow,
}

class MinidumpApi {
  const MinidumpApi.raw();

  bool hasCrashTriggers() =>
      RustLib.instance.api.crateApiMinidumpApiHasCrashTriggers(that: this);

  Future<MinidumpResult> installHandlers({required String dumpPath}) => RustLib
      .instance
      .api
      .crateApiMinidumpApiInstallHandlers(that: this, dumpPath: dumpPath);

  factory MinidumpApi() => RustLib.instance.api.crateApiMinidumpApiNew();

  bool test() => RustLib.instance.api.crateApiMinidumpApiTest(that: this);

  Future<void> triggerCrash({required CrashType crashType}) => RustLib
      .instance
      .api
      .crateApiMinidumpApiTriggerCrash(that: this, crashType: crashType);

  Future<MinidumpResult> writeDump({required String path}) =>
      RustLib.instance.api.crateApiMinidumpApiWriteDump(that: this, path: path);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MinidumpApi && runtimeType == other.runtimeType;
}

class MinidumpResult {
  final bool success;
  final String? error;

  const MinidumpResult({required this.success, this.error});

  @override
  int get hashCode => success.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MinidumpResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          error == other.error;
}
